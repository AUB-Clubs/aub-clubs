generator client {
  provider = "prisma-client"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
}

// --------------------
// Enums
// --------------------

enum ClubRole {
  MEMBER
  PRESIDENT
  VICE_PRESIDENT
}

enum PostType {
  ANNOUNCEMENT
  GENERAL
}

// --------------------
// Models
// --------------------

model User {
  id        String   @id @default(uuid()) // Note: If using Clerk, you can remove @default(uuid()) and set this manually to the Clerk ID
  aubnetId  String   @unique @map("aubnet_id")
  email     String   @unique
  firstName String   @map("first_name")
  lastName  String   @map("last_name")
  dob       DateTime @map("dob")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  memberships Membership[]
  posts       Post[]       @relation("AuthoredPosts")
  upvotes     Upvote[]

  @@map("users")
}

model Club {
  id          String  @id @default(uuid())
  crn         String  @unique
  title       String
  description String
  image       String?
  banner      String?

  // Relations
  memberships Membership[]
  posts       Post[]

  @@map("clubs")
}

model Membership {
  id       String   @id @default(uuid())
  userId   String   @map("user_id")
  clubId   String   @map("club_id")
  role     ClubRole @default(MEMBER)
  joinedAt DateTime @default(now()) @map("joined_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  club Club @relation(fields: [clubId], references: [id], onDelete: Cascade)

  // 1. Uniqueness: A user can't join the same club twice
  // 2. Performance: Implicitly indexes queries starting with 'userId' (e.g. "My Clubs")
  @@unique([userId, clubId])
  
  // Performance: Indexes queries for "Who is in this club?"
  @@index([clubId]) 
  
  @@map("memberships")
}

model Post {
  id        String   @id @default(uuid())
  title     String
  content   String
  type      PostType @default(GENERAL)
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Foreign Keys
  authorId String @map("author_id")
  clubId   String @map("club_id")

  // Relations
  author  User     @relation("AuthoredPosts", fields: [authorId], references: [id])
  club    Club     @relation(fields: [clubId], references: [id], onDelete: Cascade)
  upvotes Upvote[]

  // Performance: Critical for the Feed. 
  // Fast filtering by Club AND sorting by Date in one step.
  @@index([clubId, createdAt(sort: Desc)]) 
  
  @@map("posts")
}

model Upvote {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  postId    String   @map("post_id")
  createdAt DateTime @default(now()) @map("created_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)

  // 1. Uniqueness: One vote per user per post
  // 2. Performance: Implicitly indexes queries starting with 'userId'
  @@unique([userId, postId]) 
  
  // Performance: Indexes "Count total votes for this post"
  @@index([postId]) 
  
  @@map("upvotes")
}